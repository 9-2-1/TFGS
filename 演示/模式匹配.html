<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<div style="border:1px black solid;width:100%;font-size:20px;" type="text" id="inn" ></div>
<textarea style="width:100%;height:90%;font-size:20px;" type="text" id="out"></textarea>
<script>
	function WorkerFunc(func){
		var funcURL = window.URL.createObjectURL(
			new Blob(["(" + func.toString() + ")()"], {type:"text/javascript"})
		);
		var worker = new Worker(funcURL)
		window.URL.revokeObjectURL(funcURL);
		return worker;
	}

	var inn = document.getElementById("inn");
	var out = document.getElementById("out");
	var wok = new WorkerFunc(workerF);
	var workTime = false, workTout = -1;
	//inn.contentEditable = true;
	//inn.addEventListener('input',innChange);
	function innChange(event){
		setTimeout(function(){
			if(workTime){
				if(workTout === null){
					workTout = setInterval(function(){
						if(!workTime){
							startWork();
							clearInterval(workTout);
							workTout = null;
						}
					},30);
				}
			}else{
				startWork();
			}
		},0);
	}
	function startWork(){
		out.style.color = "blue";
		workTime = true;
		wok.postMessage(inn.innerText);
	}
	wok.onmessage = function(msg){
		workTime = false;
		out.style.color = "black";
		out.value = msg.data;
	}
	wok.onerror = function(err){
		workTime = false;
		out.style.color = "red";
		out.value = err.message;
		err.preventDefault();
	}

	out.addEventListener('focus',function(event){
		out.blur();
	});
	out.value = "Script loaded."

	function workerF() {
	// start worker
	
	onmessage = function(msg){
		postMessage(match(msg.data));
	}

	let blockText = [
		/* “.”表示输入 */
		".*.",
		"./.",
		".+.",
		".-.",
		".?.:.",
		"(.)",
		"\".\"",
		"save.to.",
		"load.from.",
		"llll.ffff.",
	];
	
	let blockType = [/*
		{
			output: 输出类型(目前为1),
			inputs: [输入类型(目前为1), ...], //有输入个个数
			texts: ["输入间穿插文本", ...]  //有输入+1个个数
		},
		...
	*/];
	
	// 从这里开始匹配。这次换一个比较直觉的方式
	function match(text){
		// 积木结构数据
		let blocksData = [{
			type: 0, // 初始文本积木
			parent: -1,
			inputs: [""]
		}/*,
		{
			type: 类型(blockText序号，0表示文本),
			parent:   外面积木序号,
			inputs:  [参数积木的序号，type=0表示文本, ...]
		}, ...
		*/];
		let blockStack = [/*
		{
			blockId: 数据位置,
			inputId:  参数位置,
			text:   匹配文字
		}, ...
		*/];
		blockTextToType();
		//return JSON.stringify(blockType);
		let debugstr = "";
		function debug(x){
			debugstr += (typeof x === "string" ? x : JSON.stringify(x)) + "\n";
			// debugstr += " ";
			if(debugstr.length > 100000){
				throw new Error("debug124554066086");
			}
		}
		try{
			guessPossibleMode();
			debugstr = String(lookString(0)) + "\n\n" + debugstr;
		}catch(e){
			debugstr = e.message + "\n\n" + debugstr;
		}
		return debugstr;
		
		function blockTextToType(){
			blockType = [{ //特殊的type=0
				output: 1,
				inputs: [1], //这里对应的是文本，不是积木编号
				texts:  ["",""]
			}];
			for(let i=0;i<blockText.length;i++){
				let str = blockText[i];
				let block = {
					output: 1, /*输出类型(目前为1)*/
					inputs: [/*输入类型(目前为1), ...*/], //有输入个个数
					texts: [/*"输入间穿插文本", ...*/]  //有输入+1个个数
				};
				let ch = "";
				for(let j=0;j<str.length;j++){
					if(str[j] === "."){
						block.texts.push(ch);
						block.inputs.push(1);
						ch = "";
					}else{
						ch += str[j];
					}
				}
				block.texts.push(ch);
				blockType.push(block);
			}
		}

		function guessPossibleMode(){
			const bT = blockType;
			let blockId = 0;
			let inputId = 0;
			let mode = 1; // 1替换还是2右结合模式
			let textI = 0;
			while(1){
				// debug(textI);
				// debug(blockStack);
				// debug(blocksData);
				debug(lookString(0));
				// guessPossibleSteps;
				let steps = [/*
				{
					text:   判定文字(可能是空的),
					stack:  返回层级 或者 -1代表新积木,
					type:   选择/连接积木类型,
					mode:   1替换或者2右结合
				}, ...
				*/];
				if(mode === 1){
					// getFirstPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] !== ""){
							steps.push({
								text:   bi.texts[0],
								stack:  -1,
								type:   i,
								mode:   1,
							});
						}
					}
				}
				
				if(true /* mode >= 1 */){
					// getSecondPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] === ""){
							steps.push({
								text:   bi.texts[1],
								stack:  -1,
								type:   i,
								mode:   2,
							});
						}
					}
					//getRollBackPattern;
					for(let i=0;i<blockStack.length;i++){
						let si = blockStack[i];
						steps.push({
							text:   si.text,
							stack:  i,
							type:  -1,
							mode:   0,
						});
					}
				}
				// debug(steps);
				// checkPossibleSteps;
				let max = 0.5, choice, mlength;
				let textI0 = textI;
				for(choice=-1;textI<text.length && choice===-1;){
					for(let i=steps.length-1;i>=0;i--){
						let si = steps[i];
						let match, score;
						let ftext = text.slice(textI, textI + Math.floor(si.text.length * 1.2));
						match = matchText(ftext, si.text);
						score = match.similarity*match.left/si.text.length;
						// debug(i+"\t"+si.text+"\t"+ftext+"\t"+match.left+"\t"+score);
						if(score > max){
							max = score;
							choice = i;
							mlength = match.left;
						}
					}
					if(choice === -1){
						textI++;
					}
				}
				if(mode === 1){
					blocksData[blockId].inputs[inputId] += text.slice(textI0,textI);
				}else{
					debug({skip:text.slice(textI0,textI)});
				}
				// doPossibleSteps;
				if(choice === -1){
					return;
				}else{
					let step = steps[choice];
					debug(step);
					textI += mlength;
					if(step.stack !== -1){
						blockStack.splice(step.stack+1,blockStack.length-step.stack-1);
						let frame = blockStack.pop();
						blockId = frame.blockId;
						inputId = frame.inputId;
						inputId++;
					}else if(step.mode === 1){
						let inputs = [];
						for(let i=0;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						blocksData.push({
							type:   step.type,
							parent: blockId,
							inputs: inputs
						});
						let bbii = blocksData[blockId].inputs[inputId];
						debug({skip:(bbii)});
						blocksData[blockId].inputs[inputId] = blocksData.length - 1;
						blockId = blocksData.length - 1;
						inputId = 0;
					}else{
						//右结合（把这个积木变成前面的积木的最后一个参数）
						//  (  A(  B  ))
						let inputs = [blocksData.length];
						for(let i=1;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						let origNode = blocksData[blockId];
						let newNode = {
							type:   step.type,
							parent: blocksData[blockId].parent,
							inputs: inputs
						}
						blocksData[blockId] = newNode;
						blocksData.push(origNode);
						//blockId = blockId;
						inputId = 1;
					}
					if(inputId !== blocksData[blockId].inputs.length){
						blockStack.push({
							blockId: blockId,
							inputId: inputId,
							text:  bT[blocksData[blockId].type].texts[inputId+1]
						})
						blocksData[blockId].inputs[inputId] = blocksData.length;
						blocksData.push({
							type: 0,
							parent: blockId,
							inputs: [""]
						})
						blockId = blocksData.length - 1;
						inputId = 0;
						mode = 1;
					}else{
						mode = 2; //不接受输入
					}
				}
			}
		}
		// 产生能看的表达方式
		function lookString(p){
			// debug("p:"+p)
			if(p === -1){
				return "?";
			}
			let block = blocksData[p];
			let type = block.type;
			if(type === 0){
				p = block.inputs[0];
				if(typeof p === "string"){
					return JSON.stringify(p);
				}else{
					return lookString(p);
				}
			}
			let bType = blockType[type];
			let ch = "[" + bType.texts[0];
			for(let i=0;i<block.inputs.length;i++){
				ch += " " + lookString(block.inputs[i]);
				ch += " " + bType.texts[i+1];
			}
			return ch + "]";
		}
		// 比较函数又被修改了。
		// 用途：直观对比字符串(a找b)
		function matchText(a,b){
			// 比对器近视程度
			let MAX_OFFSET = 10;
			let bmatch = [], strSimilar = 0, left = -1;
			for(let y=0;y<b.length;y++){
				bmatch.push(false);
			}
			for(let x=0;x<a.length;x++){
				let bestY = -1, best = 0;
				for(let y=0;y<b.length;y++){
					if(!bmatch[y]){
						let similar = 0;
						if(a[x] === b[y]){
							// 这里以后会换成更加模糊的判断
							similar = 1;
						}
						similar *= 1-Math.abs(x-y)/MAX_OFFSET;
						if(best < similar){
							best = similar;
							bestY = y;
						}
					}
				}
				if(bestY !== -1){
					bmatch[bestY] = true;
					strSimilar += best;
					left = x;
				}
			}
			left+=1;
			return {
				similarity:left === 0 ? 0 : strSimilar/left,
				left:left
			};
		}
	}
	// end worker
	}
</script>
