<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<div style="border:1px black solid;width:100%;height:auto;padding: 2px;font-size:20px;box-sizing: border-box;" type="text" id="inn" ><font color="red">123</font><font color="green">456</font>789</div>
<textarea style="width:100%;height:90%;font-size:20px;" type="text" id="out"></textarea>
<script>
	function WorkerFunc(func,callback){
		let blob = new Blob(["(" + func.toString() + ")()"], {type:"text/javascript"});
		let reader = new FileReader();
		reader.addEventListener('loadend', function(event){
			// alert(event.target.result);
			worker = new Worker(event.target.result)
			callback(worker);
		});
		reader.readAsDataURL(blob);
	}

	var inn = document.getElementById("inn");
	var out = document.getElementById("out");
	var wok;
	WorkerFunc(workerF,function(wo){
		wok = wo;
		wok.onmessage = function(msg){
			workTime = false;
			out.style.color = "black";
			out.value = msg.data.text;
			applyColorChange(msg.data.colorSet);
		}
		wok.onerror = function(err){
			workTime = false;
			out.style.color = "red";
			out.value = err.message;
			err.preventDefault();
		}
	});
	var workTime = false, workTout = -1;
	inn.contentEditable = true;
	inn.addEventListener('input',innChange);
	inn.addEventListener('paste',innChange);
	function innChange(event){
		setTimeout(function(){
			if(workTime){
				if(workTout === null){
					workTout = setInterval(function(){
						if(!workTime){
							startWork();
							clearInterval(workTout);
							workTout = null;
						}
					},30);
				}
			}else{
				startWork();
			}
		},0);
	}
	function startWork(){
		out.style.color = "blue";
		workTime = true;
		wok.postMessage(inn.innerText.replace(/[\r\n]/g,""));
	}
	function applyColorChange(colorSet){
		let tx = inn.innerText;
		let select = document.getSelection();
		let offset = select.focusOffset;
		let offNode = select.focusNode;
		while(offNode !== null && offNode.nodeName.toLowerCase() !== "div"){
			let prevNode = offNode.previousSibling;
			if(prevNode === null){
				offNode = offNode.parentElement;
			}else{
				offNode = prevNode;
				offset += offNode.innerText.length;
			}
		}
		if(offNode === null){
			return;
		}
	
		inn.innerHTML = "";
		let colorStack = [/* 颜色 */];
		let bgcolor = "white", color = "black", txI = 0, ch = "";
		let range = document.createRange(), rangeSet = false;
		for(let i=0;i<colorSet.length;i++){
			if(colorSet[i].pos !== txI){
				let font = document.createElement("font");
				font.style.color=color;
				font.style.backgroundColor=bgcolor;
				font.innerText = tx.slice(txI, colorSet[i].pos);
				inn.appendChild(font);
				if(!rangeSet && offset<=colorSet[i].pos){
					range.setStart(font.childNodes[0], offset - txI);
					range.setEnd  (font.childNodes[0], offset - txI);
					rangeSet = true;
				}
				txI = colorSet[i].pos;
			}
			switch(colorSet[i].type){
				case "push":
					colorStack.push(bgcolor);
					colorStack.push(  color);
					// break;
				case "set":
					if("color"   in colorSet[i]){
						color   = colorSet[i].color;
					}
					if("bgcolor" in colorSet[i]){
						bgcolor = colorSet[i].bgcolor;
					}
					break;
				case "pop":
					color   = colorStack.pop();
					bgcolor = colorStack.pop();
					break;
			}
		}
		if(tx.length !== txI){
			let font = document.createElement("font");
			font.style.color=color;
			font.style.backgroundColor=bgcolor;
			font.innerText = tx.slice(txI, tx.length);
			inn.appendChild(font);
			if(!rangeSet){
				range.setStart(font.childNodes[0], offset - txI);
				range.setEnd  (font.childNodes[0], offset - txI);
			}
		}
		select.removeAllRanges();
		select.addRange(range);
	}

	out.addEventListener('focus',function(event){
		out.blur();
	});
	out.value = "Script loaded."

	function workerF() {
	// start worker
	
	onmessage = function(msg){
		// setTimeout(function(){
			postMessage(match(msg.data));
		// },1000);
	}

	let blockText = [
		/* “.”表示输入 */
		".*.",
		"./.",
		".+.",
		".-.",
		".?.:.",
		"(.)",
		"\".\"",
		"save.to.",
		"load.from.",
		"llll.ffff.",
	];
	
	let blockType = [/*
		{
			output: 输出类型(目前为1),
			inputs: [输入类型(目前为1), ...], //有输入个个数
			texts: ["输入间穿插文本", ...]  //有输入+1个个数
		},
		...
	*/];
	
	// 从这里开始匹配。这次换一个比较直觉的方式
	function match(text){
		// 积木结构数据
		let blocksData = [{
			type: 0, // 初始文本积木
			parent: -1,
			inputs: [""]
		}/*,
		{
			type: 类型(blockText序号，0表示文本),
			parent:   外面积木序号,
			inputs:  [参数积木的序号，type=0表示文本, ...]
		}, ...
		*/];
		let blockStack = [/*
		{
			blockId: 数据位置,
			inputId:  参数位置,
			text:   匹配文字
		}, ...
		*/];
		let colorSet = [/*
		{
			pos:  开始变色的文字位置(绘制的时候必须递增，可以提前用sort函数做到)
			type: 类型 set=设定 push=设定但保留上一个颜色 pop=取回上一个颜色
			color:设定的颜色
		}
		*/];

		blockTextToType();
		//return JSON.stringify(blockType);
		let debugstr = "";
		function debug(x){
			debugstr += (typeof x === "string" ? x : JSON.stringify(x)) + "\n";
			// debugstr += " ";
			if(debugstr.length > 100000){
				throw new Error("debug124554066086");
			}
		}
		try{
			guessPossibleMode();
			debugstr = String(lookString(0)) + "\n\n" + debugstr;
		}catch(e){
			debugstr = e.message + "\n\n" + debugstr;
		}
		textColorExample();
		return {text:debugstr,colorSet:colorSet};
		
		function textColorExample(){
			// 演示代码开始（a变红，b变蓝，()变黄，[]变绿）
			for(let i=0;i<text.length;i++){
				switch(text[i]){
					case 'a':
						colorSet.push({
							pos:i,
							type:"push",
							color:"red",
						});
						colorSet.push({
							pos:i+1,
							type:"pop"
						});
						break;
					case 'b':
						colorSet.push({
							pos:i,
							type:"push",
							color:"blue"
						});
						colorSet.push({
							pos:i+1,
							type:"pop"
						});
						break;
					case '(':
						colorSet.push({
							pos:i,
							type:"push",
							color:"olive"
						});
						break;
					case '[':
						colorSet.push({
							pos:i,
							type:"push",
							color:"green",
							bgcolor:"lightgreen"
						});
						break;
					case ')':
					case ']':
						colorSet.push({
							pos:i+1,
							type:"pop"
						});
						break;
				}
			}
			// 演示代码结束
		}
		function blockTextToType(){
			blockType = [{ //特殊的type=0
				output: 1,
				inputs: [1], //这里对应的是文本，不是积木编号
				texts:  ["",""]
			}];
			for(let i=0;i<blockText.length;i++){
				let str = blockText[i];
				let block = {
					output: 1, /*输出类型(目前为1)*/
					inputs: [/*输入类型(目前为1), ...*/], //有输入个个数
					texts: [/*"输入间穿插文本", ...*/]  //有输入+1个个数
				};
				let ch = "";
				for(let j=0;j<str.length;j++){
					if(str[j] === "."){
						block.texts.push(ch);
						block.inputs.push(1);
						ch = "";
					}else{
						ch += str[j];
					}
				}
				block.texts.push(ch);
				blockType.push(block);
			}
		}

		function guessPossibleMode(){
			const bT = blockType;
			let blockId = 0;
			let inputId = 0;
			let mode = 1; // 1替换还是2右结合模式
			let textI = 0;
			while(1){
				// debug(textI);
				// debug(blockStack);
				// debug(blocksData);
				debug(lookString(0));
				// guessPossibleSteps;
				let steps = [/*
				{
					text:   判定文字(可能是空的),
					stack:  返回层级 或者 -1代表新积木,
					type:   选择/连接积木类型,
					mode:   1替换或者2右结合
				}, ...
				*/];
				if(mode === 1){
					// getFirstPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] !== ""){
							steps.push({
								text:   bi.texts[0],
								stack:  -1,
								type:   i,
								mode:   1,
							});
						}
					}
				}
				
				if(true /* mode >= 1 */){
					// getSecondPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] === ""){
							steps.push({
								text:   bi.texts[1],
								stack:  -1,
								type:   i,
								mode:   2,
							});
						}
					}
					//getRollBackPattern;
					for(let i=0;i<blockStack.length;i++){
						let si = blockStack[i];
						steps.push({
							text:   si.text,
							stack:  i,
							type:  -1,
							mode:   0,
						});
					}
				}
				// debug(steps);
				// checkPossibleSteps;
				let max = 0.5, choice, mlength;
				let textI0 = textI;
				for(choice=-1;textI<text.length && choice===-1;){
					for(let i=steps.length-1;i>=0;i--){
						let si = steps[i];
						let match, score;
						let ftext = text.slice(textI, textI + Math.floor(si.text.length * 1.2));
						match = matchText(ftext, si.text);
						score = match.similarity*match.left/si.text.length;
						// debug(i+"\t"+si.text+"\t"+ftext+"\t"+match.left+"\t"+score);
						if(score > max){
							max = score;
							choice = i;
							mlength = match.left;
						}
					}
					if(choice === -1){
						textI++;
					}
				}
				if(mode === 1){
					blocksData[blockId].inputs[inputId] += text.slice(textI0,textI);
				}else{
					debug({skip:text.slice(textI0,textI)});
				}
				// doPossibleSteps;
				if(choice === -1){
					return;
				}else{
					let step = steps[choice];
					debug(step);
					textI += mlength;
					if(step.stack !== -1){
						blockStack.splice(step.stack+1,blockStack.length-step.stack-1);
						let frame = blockStack.pop();
						blockId = frame.blockId;
						inputId = frame.inputId;
						inputId++;
					}else if(step.mode === 1){
						let inputs = [];
						for(let i=0;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						blocksData.push({
							type:   step.type,
							parent: blockId,
							inputs: inputs
						});
						let bbii = blocksData[blockId].inputs[inputId];
						debug({skip:(bbii)});
						blocksData[blockId].inputs[inputId] = blocksData.length - 1;
						blockId = blocksData.length - 1;
						inputId = 0;
					}else{
						//右结合（把这个积木变成前面的积木的最后一个参数）
						//  (  A(  B  ))
						let inputs = [blocksData.length];
						for(let i=1;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						let origNode = blocksData[blockId];
						let newNode = {
							type:   step.type,
							parent: blocksData[blockId].parent,
							inputs: inputs
						}
						blocksData[blockId] = newNode;
						blocksData.push(origNode);
						//blockId = blockId;
						inputId = 1;
					}
					if(inputId !== blocksData[blockId].inputs.length){
						blockStack.push({
							blockId: blockId,
							inputId: inputId,
							text:  bT[blocksData[blockId].type].texts[inputId+1]
						})
						blocksData[blockId].inputs[inputId] = blocksData.length;
						blocksData.push({
							type: 0,
							parent: blockId,
							inputs: [""]
						})
						blockId = blocksData.length - 1;
						inputId = 0;
						mode = 1;
					}else{
						mode = 2; //不接受输入
					}
				}
			}
		}
		// 产生能看的表达方式
		function lookString(p){
			// debug("p:"+p)
			if(p === -1){
				return "?";
			}
			let block = blocksData[p];
			let type = block.type;
			if(type === 0){
				p = block.inputs[0];
				if(typeof p === "string"){
					return JSON.stringify(p);
				}else{
					return lookString(p);
				}
			}
			let bType = blockType[type];
			let ch = "[" + bType.texts[0];
			for(let i=0;i<block.inputs.length;i++){
				ch += " " + lookString(block.inputs[i]);
				ch += " " + bType.texts[i+1];
			}
			return ch + "]";
		}
		// 比较函数又被修改了。
		// 用途：直观对比字符串(a找b)
		function matchText(a,b){
			// 比对器近视程度
			let MAX_OFFSET = 10;
			let bmatch = [], strSimilar = 0, left = -1;
			for(let y=0;y<b.length;y++){
				bmatch.push(false);
			}
			for(let x=0;x<a.length;x++){
				let bestY = -1, best = 0;
				for(let y=0;y<b.length;y++){
					if(!bmatch[y]){
						let similar = 0;
						if(a[x] === b[y]){
							// 这里以后会换成更加模糊的判断
							similar = 1;
						}
						similar *= 1-Math.abs(x-y)/MAX_OFFSET;
						if(best < similar){
							best = similar;
							bestY = y;
						}
					}
				}
				if(bestY !== -1){
					bmatch[bestY] = true;
					strSimilar += best;
					left = x;
				}
			}
			left+=1;
			return {
				similarity:left === 0 ? 0 : strSimilar/left,
				left:left
			};
		}
	}
	// end worker
	}
</script>
