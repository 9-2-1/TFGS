<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<input style="width:100%;font-size:20px;" type="text" id="inn" />
<textarea style="width:100%;height:90%;font-size:20px;" type="text" id="out"></textarea>
<script>
	function WorkerFunc(func){
		var funcURL = window.URL.createObjectURL(
			new Blob(["(" + func.toString() + ")()"], {type:"text/javascript"})
		);
		var worker = new Worker(funcURL)
		window.URL.revokeObjectURL(funcURL);
		return worker;
	}

	var inn = document.getElementById("inn");
	var out = document.getElementById("out");
	var wok = new WorkerFunc(workerF);
	var workTime = false, workTout = -1;
	inn.addEventListener('keydown',innChange);
	inn.addEventListener('paste',innChange);
	function innChange(event){
		setTimeout(function(){
			if(workTime){
				if(workTout === null){
					workTout = setInterval(function(){
						if(!workTime){
							startWork();
							clearInterval(workTout);
							workTout = null;
						}
					},30);
				}
			}else{
				startWork();
			}
		},0);
	}
	function startWork(){
		out.style.color = "blue";
		workTime = true;
		wok.postMessage(inn.value);
	}
	wok.onmessage = function(msg){
		workTime = false;
		out.style.color = "black";
		out.value = msg.data;
	}
	wok.onerror = function(err){
		workTime = false;
		out.style.color = "red";
		out.value = err.message;
		err.preventDefault();
	}

	out.addEventListener('focus',function(event){
		out.blur();
	});
	out.value = "Script loaded."

	function workerF() {
	// start worker
	
	onmessage = function(msg){
		postMessage(match(msg.data));
	}

	let blockText = [
		/* “.”表示输入 */
		".*.",
		"./.",
		".+.",
		".-.",
		".?.:.",
		"(.)",
		"\".\"",
		"save.to.",
		"load.from.",
	];
	
	let blockType = [/*
		{
			output: 输出类型(目前为1),
			inputs: [输入类型(目前为1), ...], //有输入个个数
			texts: ["输入间穿插文本", ...]  //有输入+1个个数
		},
		...
	*/];
	
	// 从这里开始匹配。这次换一个比较直觉的方式
	function match(text){
		// 积木结构数据
		let data = [
		{
			type: -1/*代表开始点*/,
			parent:   -1,
			args:  [-1/*开始积木编号*/]
			// 开始的时候，编辑的的参数位置就是这里
		}/*,
		// 接下来是正常的数据格式
		{
			type: 类型(blockText序号),
			parent:   外面积木序号,
			args:  [参数积木的序号(-1表示没有), ...]
		}, ...
		*/];
		let stack = [/*
		{
			dataId: 数据位置,
			argId:  参数位置,
			text:   匹配文字
		}, ...
		*/];
		blockTextToType();
		//return JSON.stringify(blockType);
		let debugstr = "";
		function debug(x){
			debugstr += (typeof x === "string" ? x : JSON.stringify(x)) + "\n";
			// debugstr += " ";
			if(debugstr.length > 100000){
				throw new Error("debug124554066086");
			}
		}
		try{
			guessPossibleMode();
			debugstr = lookString(0) + "\n\n" + debugstr;
		}catch(e){
			debugstr = e.message + "\n\n" + debugstr;
		}
		return debugstr;
		
		function blockTextToType(){
			blockType = [];
			for(let i=0;i<blockText.length;i++){
				let str = blockText[i];
				let block = {
					output: 1, /*输出类型(目前为1)*/
					inputs: [/*输入类型(目前为1), ...*/], //有输入个个数
					texts: [/*"输入间穿插文本", ...*/]  //有输入+1个个数
				};
				let ch = "";
				for(let j=0;j<str.length;j++){
					if(str[j] === "."){
						block.texts.push(ch);
						block.inputs.push(1);
						ch = "";
					}else{
						ch += str[j];
					}
				}
				block.texts.push(ch);
				blockType.push(block);
			}
		}

		function guessPossibleMode(){
			stack = [];
			let dataId = 0;
			let argId = 0;
			let mode = 1;
			let textI = 0;
			while(1){
				// debug(textI);
				// debug(stack);
				// debug(data);
				// debug(lookString(0));
				// guessPossibleSteps;
				let steps = [/*
				{
					text:   判定文字(可能是空的),
					stack:  返回层级 或者 -1代表新积木,
					type:   选择/连接积木类型,
					mode:   1选择，2连接(考虑优先导致重组)
				}, ...
				*/];
				if(mode === 1){
					//getFirstPlacePattern;
					for(let i=0;i<pD.length;i++){
						let pi = pD[i];
						if(pi.texts[0] !== ""){
							steps.push({
								text:   pi.texts[0],
								stack:  -1,
								type: i,
								mode:   1,
							});
						}
					}
				}
				
				if(true /* mode >= 1 */){
					//getSecondPlacePattern;
					for(let i=0;i<pD.length;i++){
						let pi = pD[i];
						if(pi.texts[0] === ""){
							steps.push({
								text:   pi.texts[1],
								stack:  -1,
								type: i,
								mode:   2,
							});
						}
					}
					//getRollBackPattern;
					for(let i=0;i<stack.length;i++){
						let li = stack[i];
						steps.push({
							text:   li.text,
							stack:  i,
							type: -1,
							mode:   0,
						});
					}
				}
				// debug(steps);
				// checkPossibleSteps;
				let max = 0.5, choice;
				let textI0 = textI;
				for(choice=-1;textI<text.length && choice===-1;textI++){
					for(let i=steps.length-1;i>=0;i--){
						let si = steps[i];
						let score;
						if(si.text === ""){
							score = 0;
						}else{
							let ftext = text.slice(textI,textI + si.text.length);
							let diff = diffText(si.text,ftext,1,1);
							score = (si.text.length + ftext.length - diff) / 2 / si.text.length;
							// debug(i+"\t"+si.text+"\t"+ftext+"\t"+score);
						}
						if(score > max){
							max = score;
							choice = i;
						}
					}
				}
				debug({skip:text.slice(textI0,textI-1)});
				// doPossibleSteps;
				if(choice === -1){
					return;
				}else{
					let step = steps[choice];
					// debug(step);
					textI += step.text.length - 1;
					if(step.stack !== -1){
						stack.splice(step.stack+1,stack.length-step.stack-1);
						let frame = stack.pop();
						dataId = frame.dataId;
						argId = frame.argId;
						argId++;
					}else if(step.mode === 1){
						let args = [];
						for(let i=0;i<pD[step.type].inputs.length;i++){
							args.push(-1);
						}
						data.push({
							type: step.type,
							parent:   dataId,
							args:  args
						});
						data[dataId].args[argId] = data.length - 1;
						dataId = data.length - 1;
						argId = 0;
					}else{
						//巨难无比
						//这里有两个方法：
						// (1) 左结合（把前面的积木换成这个积木的第一个参数）
						//  ((  A  )B  )
						// (2) 右结合（把这个积木变成前面的积木的最后一个参数）
						//  (  A(  B  ))
						let method = 1;
						// 判断使用什么方法：
						// 检查不能左结合情况
						// A不是最后一个参数？
						var tA = data[dataId].type;
						var tB = step.type;
						if(argId !== data[dataId].args.length-1){
							debug("i");
							method = 2;
						}
						debug("ii");
						debug(tA);
						debug(tB);
						if(tA !== -1 && tB !== -1 && pD[tA].texts[pD[tA].texts.length-1] === ""
						&& pD[tB].texts[0] === ""
						&& tA > tB){
							debug("II");
							method = 2;
						}
						if(method === 1){
							let args = [data.length];
							for(let i=1;i<pD[step.type].inputs.length;i++){
								args.push(-1);
							}
							let origNode = data[dataId];
							let newNode = {
								type: step.type,
								parent:   data[dataId].parent,
								args:  args
							}
							data[dataId] = newNode;
							data.push(origNode);
							//dataId = dataId;
							argId = 1;
						}else{
							let args = [];
							for(let i=0;i<pD[step.type].inputs.length;i++){
								args.push(-1);
							}
							data.push({
								type: step.type,
								parent:   dataId,
								args:  args
							});
							data[dataId].args[argId] = data.length - 1;
							dataId = data.length - 1;
							argId = 1;
						}
					}
					if(argId !== data[dataId].args.length){
						stack.push({
							dataId:dataId,
							argId: argId,
							text:  pD[data[dataId].type].texts[argId+1]
						})
						mode = 1;
					}else{
						mode = 2; //不接受输入
					}
				}
			}
		}
		// 产生能看的表达方式
		function lookString(p){
			if(p === -1){
				return "_";
			}
			let dp = data[p];
			// debug("p:"+p)
			let type = dp.type;
			if(type === -1){
				return lookString(dp.args[0]);
			}else{
				let pDp = blockType[type];
				let ch = "[" + pDp.texts[0];
				for(let i=0;i<dp.args.length;i++){
					ch += " " + lookString(dp.args[i]);
					ch += " " + pDp.texts[i+1];
				}
				return ch + "]";
			}
		}
		// 这个函数计算的是a和b之间的编辑距离
		// 错过a的一个字符，距离增加wa，b则增加wb
		function diffText(a,b,wa,wb){
			var dp = [], leftup;
			for(var x=0;x<=a.length;x++){
				dp.push(x * wa);
			}
			for(var y=0;y<b.length;y++){
				leftup = dp[0];
				dp[0] = (y+1) * wb;
				for(var x=0;x<a.length;x++){
					let min = Math.min(
						dp[ x ] + wa,
						dp[x+1] + wb,
						leftup + (a[x]===b[y] ? 0 :
						wa + wb)
					);
					leftup = dp[x+1];
					dp[x+1] = min;
				}
			}
			return dp[a.length];
		}
	}
	// end worker
	}
</script>
