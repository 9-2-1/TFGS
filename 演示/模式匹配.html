<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<div style="
border:1px black solid;
width:100%;
padding:1px;
font-family:courier,monospace;
font-size:20px;
box-sizing:border-box;"
id="inn"></div>

<textarea style="
width:100%;
height:90%;
font-family:courier,monospace;
font-size:20px;"
id="out"></textarea>

<script>
	function WorkerFunc(func,callback){
		let blob = new Blob(["(" + func.toString() + ")()"], {type:"text/javascript"});
		let reader = new FileReader();
		reader.addEventListener('loadend', function(event){
			// alert(event.target.result);
			worker = new Worker(event.target.result)
			callback(worker);
		});
		reader.readAsDataURL(blob);
	}

	var inn = document.getElementById("inn");
	var out = document.getElementById("out");
	var wok;
	WorkerFunc(workerF,function(wo){
		wok = wo;
		wok.onmessage = function(msg){
			workTime = false;
			out.style.color = "black";
			out.value = msg.data.text;
			applyColorChange(msg.data.colorSet);
		}
		wok.onerror = function(err){
			workTime = false;
			out.style.color = "red";
			out.value = err.message;
			err.preventDefault();
		}
	});
	var workTime = false, workTout = -1;
	inn.contentEditable = true;
	inn.addEventListener('input',innChange);
	inn.addEventListener('paste',innChange);
	function innChange(event){
		setTimeout(function(){
			if(workTime){
				if(workTout === null){
					workTout = setInterval(function(){
						if(!workTime){
							startWork();
							clearInterval(workTout);
							workTout = null;
						}
					},30);
				}
			}else{
				startWork();
			}
		},0);
	}
	function startWork(){
		out.style.color = "blue";
		workTime = true;
		wok.postMessage(inn.innerText.replace(/[\r\n]/g,""));
	}
	function applyColorChange(colorSet){
		let tx = inn.innerText;
		let select = document.getSelection();
		let offset = select.focusOffset;
		let offNode = select.focusNode;
		while(offNode !== null && offNode.nodeName.toLowerCase() !== "div"){
			let prevNode = offNode.previousSibling;
			if(prevNode === null){
				offNode = offNode.parentElement;
			}else{
				offNode = prevNode;
				offset += offNode.innerText.length;
			}
		}
		if(offNode === null){
			return;
		}
	
		inn.innerHTML = "";
		let colorStack = [/* 颜色 */];
		let bgcolor = "white", color = "black", txI = 0, ch = "";
		let range = document.createRange(), rangeSet = false;
		for(let i=0;i<colorSet.length;i++){
			if(colorSet[i].pos !== txI){
				let font = document.createElement("font");
				font.style.color=color;
				font.style.backgroundColor=bgcolor;
				font.innerText = tx.slice(txI, colorSet[i].pos);
				inn.appendChild(font);
				if(!rangeSet && offset<=colorSet[i].pos){
					range.setStart(font.childNodes[0], offset - txI);
					range.setEnd  (font.childNodes[0], offset - txI);
					rangeSet = true;
				}
				txI = colorSet[i].pos;
			}
			switch(colorSet[i].type){
				case "push":
					colorStack.push(bgcolor);
					colorStack.push(  color);
					// break;
				case "set":
					if("color"   in colorSet[i]){
						color   = colorSet[i].color;
					}
					if("bgcolor" in colorSet[i]){
						bgcolor = colorSet[i].bgcolor;
					}
					break;
				case "pop":
					color   = colorStack.pop();
					bgcolor = colorStack.pop();
					break;
			}
		}
		if(tx.length !== txI){
			let font = document.createElement("font");
			font.style.color=color;
			font.style.backgroundColor=bgcolor;
			font.innerText = tx.slice(txI, tx.length);
			inn.appendChild(font);
			if(!rangeSet){
				range.setStart(font.childNodes[0], offset - txI);
				range.setEnd  (font.childNodes[0], offset - txI);
			}
		}
		select.removeAllRanges();
		select.addRange(range);
	}

	out.addEventListener('focus',function(event){
		out.blur();
	});
	out.value = "Script loaded."

	function workerF() {
	// start worker
	
	onmessage = function(msg){
		// setTimeout(function(){
			postMessage(match(msg.data));
		// },1000);
	}

	let blockText = [
		/* “.”表示输入 */
		".*.",
		"./.",
		".+.",
		".-.",
		".?.:.",
		"(.)",
		"\".\"",
		"load.disk1.",
		"load.disk2.",
		"load.disk3.",
		"loaddisk1.",
		"save.disk3.",
	];
	
	let blockType = [/*
		{
			output: 输出类型(目前为1),
			inputs: [输入类型(目前为1), ...], //有输入个个数
			texts: ["输入间穿插文本", ...]  //有输入+1个个数
		},
		...
	*/];
	
	// 从这里开始匹配。这次换一个比较直觉的方式
	function match(text){
		const cTypeTable = [
			" \t　\u00A0", // 空白，\t左边是半角空格，右边是全角空格
			"\"“”",  // 引号
			"\'‘’",  // 引号2
			"()（）",// 括号
			"0123456789",
			"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
			",.?!:;…~_-'/@*+()<>{}[]=%&$|\\#¥\"^`",
			"，。？！：；…～“”、（）—‘’·@＆＊＃《》￥〈〉＄［］￡｛｝￠【】％〖〗／〔〕＼『』＾「」｜﹁﹂—｀．"
		];
		const CTYPE_SPACE = 0;
		const CTYPE_QUOTES = [1, 2];
		const CTYPE_BRACS = 3;
		// 积木结构数据
		let blocksData = [{
			type: 0, // 初始文本积木
			parent: -1,
			inputs: [""]
		}/*,
		{
			type: 类型(blockText序号，0表示文本),
			parent:   外面积木序号,
			inputs:  [参数积木的序号，type=0表示文本, ...]
		}, ...
		*/];
		let blockStack = [/*
		{
			blockId: 数据位置,
			inputId:  参数位置,
			text:   匹配文字
		}, ...
		*/];
		let colorSet = [/*
		{
			pos:  开始变色的文字位置(绘制的时候必须递增，可以提前用sort函数做到)
			type: 类型 set=设定 push=设定但保留上一个颜色 pop=取回上一个颜色
			color:设定的颜色
		}
		*/];

		blockTextToType();
		//return JSON.stringify(blockType);
		let debugstr = "";
		function debug(x){
			debugstr += (typeof x === "string" ? x : JSON.stringify(x)) + "\n";
			// debugstr += " ";
			if(debugstr.length > 100000){
				throw new Error("debug124554066086");
			}
		}
		try{
			guessPossibleMode();
			debugstr = String(lookString(0)) + "\n\n" + debugstr;
		}catch(e){
			debugstr = e.message + "\n\n" + debugstr;
		}
		return {text:debugstr,colorSet:colorSet};
		
		function textColor(color,bgcolor,start,end){
			let cSet = {
				pos:start,
				type:"push",
			}
			if(color){
				cSet.color = color;
			}
			if(bgcolor){
				cSet.bgcolor = bgcolor;
			}
			colorSet.push(cSet);
			colorSet.push({
				pos:end,
				type:"pop"
			});
		}
		function blockTextToType(){
			blockType = [{ //特殊的type=0
				output: 1,
				inputs: [1], //这里对应的是文本，不是积木编号
				texts:  ["",""]
			}];
			for(let i=0;i<blockText.length;i++){
				let str = blockText[i];
				let block = {
					output: 1, /*输出类型(目前为1)*/
					inputs: [/*输入类型(目前为1), ...*/], //有输入个个数
					texts: [/*"输入间穿插文本", ...*/]  //有输入+1个个数
				};
				let ch = "";
				for(let j=0;j<str.length;j++){
					if(str[j] === "."){
						block.texts.push(ch);
						block.inputs.push(1);
						ch = "";
					}else{
						ch += str[j];
					}
				}
				block.texts.push(ch);
				blockType.push(block);
			}
		}

		function guessPossibleMode(){
			const bT = blockType;
			let blockId = 0;
			let inputId = 0;
			let mode = 1; // 1替换还是2右结合模式
			let textI = 0;
			while(1){
				// debug(textI);
				// debug(blockStack);
				// debug(blocksData);
				debug(lookString(0));
				// guessPossibleSteps;
				let steps = [/*
				{
					text:   判定文字(可能是空的),
					stack:  返回层级 或者 -1代表新积木,
					type:   选择/连接积木类型,
					mode:   1替换或者2右结合
				}, ...
				*/];
				if(mode === 1){
					// getFirstPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] !== ""){
							steps.push({
								text:   bi.texts[0],
								stack:  -1,
								type:   i,
								mode:   1,
							});
						}
					}
				}
				
				if(true /* mode >= 1 */){
					// getSecondPlacePattern;
					for(let i=0;i<bT.length;i++){
						let bi = bT[i];
						if(bi.texts[0] === ""){
							steps.push({
								text:   bi.texts[1],
								stack:  -1,
								type:   i,
								mode:   2,
							});
						}
					}
					//getRollBackPattern;
					for(let i=0;i<blockStack.length;i++){
						let si = blockStack[i];
						steps.push({
							text:   si.text,
							stack:  i,
							type:  -1,
							mode:   0,
						});
					}
				}
				// debug(steps);
				// checkPossibleSteps;
				const SCORE_INPUT = 0.5;
				const PINYIN_DEC = 0.9;
				let choice = -1;
				let max = (mode === 1 ? SCORE_INPUT : 0), textIto;
				let textI0 = textI;
				let haveString = false;
				while(textI<text.length && choice===-1){
					// 处理一段相似字符
					for(let i=steps.length-1;i>=0;i--){
						let si = steps[i];
						if(haveString && si.mode === 1){
							continue;
						}
						let stext = si.text;
						//let stextP = getPinYin(stext);
						let subScore, subMax = 0, subTextIto;
						let subTextI = textI;
						while(textI<text.length){
							subTextI = gWord(subTextI);
							let ftext = text.slice(textI, subTextI);
							//let ftextP = getPinYin(ftext);
							let match, subScore/*, subScoreP*/;
							match = matchText(ftext, stext);
							subScore = match.similarity/* * match.left*/;
							debug(i+"\t"+stext+"\t"+ftext+"\t"+match.left+"\t"+subScore);
							//match = matchText(ftextP, stextP);
							//subScoreP = match.similarity * match.left * PINYIN_DEC;
							//debug(i+"\t"+stextP+"\t"+ftextP+"\t"+match.left+"\t"+scoreP);
							//if(subScoreP > subScore){
							//	subScore = subScoreP;
							//}
							if(subScore > subMax){
								subMax = subScore;
								subTextIto = subTextI;
							}else{
								break;
							}
						}
						if(subMax > max){
							max = subMax;
							choice = i;
							textIto = subTextIto;
						}
					}
					if(choice === -1){
						debug({text:text[textI].charCodeAt(0),cType:cType(text[textI]),CTYPE_SPACE:CTYPE_SPACE});
						if(cType(text[textI]) !== CTYPE_SPACE){
							haveString = true;
						}else{
							//textI0 = textI;
						}
						textI = gWord(textI);
					}
				}
				let textI1 = textI;
				if(mode === 1){
					blocksData[blockId].inputs[inputId] = text.slice(textI0,textI).trim();
				}else{
					debug({skip:text.slice(textI0,textI)});
				}
				// doPossibleSteps;
				if(choice === -1){
					if(mode === 1){
						textColor("black","white",textI0,textI1);
					}else{
						textColor("red","pink",textI0,textI1);
					}
					return;
				}else{
					textI = textIto;
					let step = steps[choice];
					debug(step);
					if(step.stack !== -1){
						if(mode === 1){
							textColor("black","white",textI0,textI1);
						}else{
							textColor("red","pink",textI0,textI1);
						}
						blockStack.splice(step.stack+1,blockStack.length-step.stack-1);
						let frame = blockStack.pop();
						blockId = frame.blockId;
						inputId = frame.inputId;
						inputId++;
					}else if(step.mode === 1){
						textColor("red","pink",textI0,textI1);
						let inputs = [];
						for(let i=0;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						blocksData.push({
							type:   step.type,
							parent: blockId,
							inputs: inputs
						});
						let bbii = blocksData[blockId].inputs[inputId];
						debug({skip:(bbii)});
						blocksData[blockId].inputs[inputId] = blocksData.length - 1;
						blockId = blocksData.length - 1;
						inputId = 0;
					}else{
						//右结合（把这个积木变成前面的积木的最后一个参数）
						//  (  A(  B  ))
						if(mode === 1){
							textColor("black","white",textI0,textI1);
						}else{
							textColor("red","pink",textI0,textI1);
						}
						let inputs = [blocksData.length];
						for(let i=1;i<bT[step.type].inputs.length;i++){
							inputs.push(-1);
						}
						let origNode = blocksData[blockId];
						let newNode = {
							type:   step.type,
							parent: blocksData[blockId].parent,
							inputs: inputs
						}
						blocksData[blockId] = newNode;
						blocksData.push(origNode);
						//blockId = blockId;
						inputId = 1;
					}
					const stackColor = [
						"#800",
						"#880",
						"#080",
						"#008",
						"#808",
					];
					let color = stackColor[blockStack.length % stackColor.length];
					textColor("white",color,textI1,textI);
					if(inputId !== blocksData[blockId].inputs.length){
						blockStack.push({
							blockId: blockId,
							inputId: inputId,
							text:  bT[blocksData[blockId].type].texts[inputId+1]
						})
						blocksData[blockId].inputs[inputId] = blocksData.length;
						blocksData.push({
							type: 0,
							parent: blockId,
							inputs: [""]
						})
						blockId = blocksData.length - 1;
						inputId = 0;
						mode = 1;
					}else{
						mode = 2; //不接受输入
					}
				}
			}
		}
		
		function gWord(textI){
			let type = cType(text[textI]);
			textI++;
			if(type===4||type===5){
				while(textI<text.length && cType(text[textI])===type){
					textI++;
				}
			}
			return textI;
		}
		
		function cType(x){
			let i;
			for(i=0;i<cTypeTable.length;i++){
				if(cTypeTable[i].includes(x)){
					break;
				}
			}
			return i;
		}
		// 产生能看的表达方式
		function lookString(p){
			// debug("p:"+p)
			if(p === -1){
				return "?";
			}
			let block = blocksData[p];
			let type = block.type;
			if(type === 0){
				p = block.inputs[0];
				if(typeof p === "string"){
					return JSON.stringify(p);
				}else{
					return lookString(p);
				}
			}
			let bType = blockType[type];
			let ch = "[" + bType.texts[0];
			for(let i=0;i<block.inputs.length;i++){
				ch += " " + lookString(block.inputs[i]);
				ch += " " + bType.texts[i+1];
			}
			return ch + "]";
		}
		// 比较函数又被修改了。
		// 用途：直观对比字符串(a找b)
		function matchText(a,b){
			// 比对器近视程度
			const MAX_OFFSET = 10;
			let bmatch = [], strSimilar = 0, left = -1;
			if(a===""){
				return {
					similarity: 0,
					left: 0
				}
			}
			for(let y=0;y<b.length;y++){
				bmatch.push(false);
			}
			for(let x=0;x<a.length;x++){
				let bestY = -1, best = 0;
				for(let y=0;y<b.length;y++){
					if(!bmatch[y]){
						let similar = 0;
						if(a[x] === b[y]){
							// 这里以后会换成更加模糊的判断
							similar = 1;
						}
						similar *= 1-Math.abs(x/a.length-y/b.length)*(a.length+b.length)/2/MAX_OFFSET;
						if(best < similar){
							best = similar;
							bestY = y;
						}
					}
				}
				if(bestY !== -1){
					bmatch[bestY] = true;
					strSimilar += best;
					left = x;
				}
			}
			left+=1;
			return {
				similarity: strSimilar/(a.length+b.length)*2,
				left: left
			};
		}
	}
	// end worker
	}
</script>
