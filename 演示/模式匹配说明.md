用于分析输入字符串中可能的模式（内置加减乘除，not or and，?:运算，括号，if then else）

演示操作：输入字符串，查看下面模糊判断的表达式的关键字结构，输出格式：

第一行：当前允许错误等级（几点五，代表输入可以错几个字，会根据结果数量调整）

之后的行：错误数值 + 模式猜测

例如：

```
(1+2)-3/4
if 3 then 5
is 4 if not 3 and 5 than 2 then 5 else 5 else 7
((23+4)/43))*(5/6
```

原理：

从"."开始尝试data数组中的模板的任意组合("."代表任意字符或者模板，例如".+."代表加法，"(.)"代表括号)，如果发现错误可能性变高就回退，否则记录，也就是贪心

里面使用了一个数组来表示模板的组合方式，格式是[模板编号，参数1，参数2，...]，参数和模板里的"."一一对应。

有一个列表维护可以插入参数的位置。每一次尝试插入参数，立即计算错误可能性，如果变大，就回退（此时不回退的话增加错误率的模板会一直存在，不如去掉），否则，将这个模板的输入放入列表中。当输入被处理的时候会从列表中暂时移到函数临时变量里

计算错误可能性的方法类似于最小编辑数算法，不同的是每错过一个模板中的字符，错误数增加“待匹配字符串的字数”；每错过一个待匹配字符串的字符，错误数只增加“允许错误等级”。因为用户一般犯错率很小，而作为模板字符串，错过待匹配字符串是常有的事，因此如此设计。如果无法匹配，将会自动调大错误等级。可以大致认为错误等级等于用户可以输错的字符数。错误等级上限越大，容错度越高，处理速度会更慢。

目前遇到的问题：在处理类似"1+1+1+1+1+1+1+1+1"这样的字符串时，因为这样的+的可能组合方式很多（例如((.+.)+(.+.))和(((.+.)+.)+.)是不同方式），会导致处理时间快速上升，导致卡慢。目前打算对相关模板使用规则来防止类似现象发生，例如禁止((.+.)+.)类模式（只保留(.+(.+.))模式），同时实现运算自动按照优先级匹配的功能。

在处理大量三目运算符（例如?:，if then）的时候，会非常卡（例如`?:?:??::?:??:?::`），因为有很多种可能性。在实战中由于?:之间的输入有类型限制，错误的可能应该会被第一时间忽略。